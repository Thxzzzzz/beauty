

package test

import (
	"context"
	"log"
	"time"

)

//Service ..
type Service interface {
	Start(ctx context.Context) error
	Stop(ctx context.Context) error
}

//App ..
type App struct {
	cycle    *lifecycle.Cycle
	services []Service
	logger   *log.Logger
}

//New ..
func New() *App {
	a := &App{}
	return a
}
func (a *App) new() error {
	//init life cycle
	a.cycle = lifecycle.New()
	a.services = make([]Service, 0)
	a.logger = &log.Logger{}
	//todo init log
	return nil
}
func (a *App) waitSignals() {
	//init listen signal
	signals.Shutdown(func() {
		a.Shutdown()
	})
}

//Shutdown ..
func (a *App) Shutdown() {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()
	for _, s := range a.services {
		func(s Service) {
			a.cycle.Run(func() error {
				return s.Stop(ctx)
			})
		}(s)
	}
	select {
	case <-a.cycle.Done():
		//grace shutdown
	case <-ctx.Done():
		//timeout shutdown
	}
	a.cycle.Close()
}

//Run ..
func (a *App) Run(services ...Service) error {
	//new app
	err := a.new()
	if err != nil {
		return err
	}
	a.waitSignals()
	a.services = append(a.services, services...)
	//start service
	for _, s := range a.services {
		func(s Service) {
			a.cycle.Run(func() error {
				return s.Start(context.TODO())
			})
		}(s)
	}
	<-a.cycle.Wait()
	return nil
}
